# -*- coding: utf-8 -*-
"""Recogintion_of_objects_final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1feWZCvb170yRWvqDBz_y1qADzwPFwxSD
"""

from python_utils import converters
import tensorflow as tf
from matplotlib import pyplot as plt
from keras.utils.np_utils import to_categorical

(x_train,y_train),(x_test,y_test)=tf.keras.datasets.cifar10.load_data()

print(x_train[0].shape)

fig, axs=plt.subplots(4,4,figsize=(10,15))


for i,ax in enumerate(axs.flat):
    ax.matshow(x_train[i])
    ax.axis('off')
    ax.plot()

x_train=x_train.reshape(x_train.shape[0],32,32,3)
x_test=x_test.reshape(x_test.shape[0],32,32,3)
x_train=x_train.astype('float32')
x_test=x_test.astype('float32')
x_train/=255
x_test/=255
n_classes=10
Y_train=to_categorical(y_train,n_classes)
Y_test=to_categorical(y_test,n_classes)

from keras.models import Sequential 
from keras.layers.convolutional import Conv2D
from keras.layers import Dense,MaxPool2D, Dropout,Flatten
from keras import losses 
model= Sequential()

#convolutional layer 
model.add(Conv2D(75,kernel_size=(3,3),strides=(1,1),padding='same',activation='relu',input_shape=(32,32,3)))

model.add(Conv2D(50,kernel_size=(2,2),strides=(1,1),padding='same',activation='relu'))
model.add(MaxPool2D(pool_size=(2,2)))
model.add(Dropout(0.15))

model.add(Conv2D(34,kernel_size=(1,1),strides=(1,1),padding='same',activation='relu'))
model.add(MaxPool2D(pool_size=(4,4)))
model.add(Dropout(0.11))


#concatination layer 
model.add(Flatten())

#hidden layers
model.add(Dense(500,activation='relu'))
model.add(Dropout(0.25))
model.add(Dense(250,activation='relu'))
model.add(Dropout(0.45))

#output layer
model.add(Dense(10,activation='softmax'))

#compiling
model.compile(loss='categorical_crossentropy',metrics=['accuracy'],optimizer='adam')

#model fitting
model.fit(x_train,Y_train,batch_size=128,epochs=10,validation_data=(x_test,Y_test))

#working of dense layer
import numpy as mp
#values in the matrices are taken arbitarily
input_shape=[[2,3],[3,4]]
kernel_size=[[4,3],[4,5]]
print(mp.dot(input_shape,kernel_size))

model.evaluate(x_test,Y_test)

"""PREDICTION"""

import numpy as np

classes=range(0,10)

names = ['airplane',
        'automobile',
        'bird',
        'cat',
        'deer',
        'dog',
        'frog',
        'horse',
        'ship',
        'truck']

# zip the names and classes to make a dictionary of class_labels
class_labels = dict(zip(classes, names))

# generate batch of 9 images to predict
batch = x_test[1209:1218]
labels = np.argmax(Y_test[1209:1218],axis=-1)

# make predictions
predictions = model.predict(batch, verbose = 1)

print(predictions)

class_result = np.argmax(predictions,axis=-1)
print (class_result)

fig, axs = plt.subplots(3, 3, figsize = (19,6))
fig.subplots_adjust(hspace = 1)
axs = axs.flatten()

for i, img in enumerate(batch):
    for key, value in class_labels.items():
        if class_result[i] == key:
            title = 'Prediction: {}\nActual: {}'.format(class_labels[key], class_labels[labels[i]])
            axs[i].set_title(title)
            axs[i].axes.get_xaxis().set_visible(False)
            axs[i].axes.get_yaxis().set_visible(False)
            
    # plot the image
    axs[i].imshow(img)
    
# show the plot
plt.show()